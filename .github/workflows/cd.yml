name: CD - Deploy to AKS

on:
  # Auto-deploy only when CI for a PUSH to main finishes successfully
  workflow_run:
    workflows: ["CI - Build & Test"]
    types: [completed]
    branches: [main]

  # Manual deploy from Actions UI with environment selection
  workflow_dispatch:
    inputs:
      environment:
        description: "Target Environment"
        required: true
        default: "production"
        type: choice
        options:
        - production
        - staging
      aks_resource_group:
        description: "AKS Resource Group"
        required: true
        default: "deakinuni"
      aks_cluster_name:
        description: "AKS Cluster Name"
        required: true
        default: "deakinstellak8s"
      namespace:
        description: "Kubernetes Namespace"
        required: true
        default: "default"
      image_tag:
        description: "Image Tag (leave empty to use latest from main)"
        required: false

# Prevent overlapping duplicate runs
concurrency:
  group: cd-${{ github.event.inputs.environment || 'production' }}
  cancel-in-progress: true

env:
  REGISTRY: "${{ secrets.AZURE_CONTAINER_REGISTRY }}"

jobs:
  deploy:
    name: Deploy to AKS
    # Auto: run only if the triggering CI succeeded, branch is main, AND the CI was for a PUSH event
    # Manual: always allowed
    if: >
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'workflow_run' &&
       github.event.workflow_run.conclusion == 'success' &&
       github.event.workflow_run.head_branch == 'main' &&
       github.event.workflow_run.event == 'push')

    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write

    steps:
      # --- Deployment Context & Safety Checks ---
      - name: Display deployment context
        run: |
          echo "üöÄ Starting deployment..."
          echo "Event: ${{ github.event_name }}"
          echo "Environment: ${{ github.event.inputs.environment || 'production' }}"
          echo "Target Namespace: ${{ github.event.inputs.namespace || 'default' }}"
          echo "Registry: ${{ env.REGISTRY }}"

      - name: Debug trigger context
        if: ${{ github.event_name == 'workflow_run' }}
        run: |
          echo "üîç Workflow Run Context:"
          echo "  Triggering workflow: ${{ github.event.workflow_run.name }}"
          echo "  Event type: ${{ github.event.workflow_run.event }}"
          echo "  Head branch: ${{ github.event.workflow_run.head_branch }}"
          echo "  Conclusion: ${{ github.event.workflow_run.conclusion }}"
          echo "  Workflow run ID: ${{ github.event.workflow_run.id }}"

      # --- Repository & Authentication Setup ---
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Azure Login (Service Principal)
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Set AKS context
        run: |
          echo "üîê Configuring AKS access..."
          az aks get-credentials \
            -g "${{ github.event.inputs.aks_resource_group || 'deakinuni' }}" \
            -n "${{ github.event.inputs.aks_cluster_name   || 'deakinstellak8s' }}" \
            --overwrite-existing
          
          echo "‚úÖ AKS context configured"
          kubectl cluster-info

      - name: Ensure namespace exists
        run: |
          NS="${{ github.event.inputs.namespace || 'default' }}"
          echo "üìÅ Ensuring namespace '$NS' exists..."
          kubectl get ns "$NS" || kubectl create ns "$NS"
          echo "‚úÖ Namespace ready"

      # --- Image Tag Resolution ---
      # Auto mode: download the artifact from the triggering CI run
      - name: Download deploy manifest from CI
        if: ${{ github.event_name == 'workflow_run' }}
        uses: actions/download-artifact@v4
        with:
          name: deploy-manifest
          path: .
          run-id: ${{ github.event.workflow_run.id }}
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Read deploy manifest (auto deployment)
        id: manifest_auto
        if: ${{ github.event_name == 'workflow_run' }}
        run: |
          echo "üìÑ Reading deploy manifest from CI..."
          cat deploy-manifest.json
          echo "TAG=$(jq -r .tag deploy-manifest.json)"           >> "$GITHUB_OUTPUT"
          echo "REGISTRY=$(jq -r .registry deploy-manifest.json)" >> "$GITHUB_OUTPUT"
          echo "COMMIT_SHA=$(jq -r .commit_sha deploy-manifest.json)" >> "$GITHUB_OUTPUT"

      # Manual mode: use provided tag or current commit's short SHA
      - name: Set manifest for manual deployment
        id: manifest_manual
        if: ${{ github.event_name == 'workflow_dispatch' }}
        run: |
          if [ -n "${{ github.event.inputs.image_tag }}" ]; then
            TAG="${{ github.event.inputs.image_tag }}"
            echo "üè∑Ô∏è  Using provided image tag: $TAG"
          else
            TAG="sha-${GITHUB_SHA::7}"
            echo "üè∑Ô∏è  Using current commit tag: $TAG"
          fi
          echo "TAG=$TAG" >> "$GITHUB_OUTPUT"
          echo "REGISTRY=${REGISTRY}" >> "$GITHUB_OUTPUT"

      # Normalize outputs for consistent access
      - name: Set final deployment manifest
        id: manifest
        run: |
          if [ "${{ github.event_name }}" = "workflow_run" ]; then
            echo "TAG=${{ steps.manifest_auto.outputs.TAG }}"             >> "$GITHUB_OUTPUT"
            echo "REGISTRY=${{ steps.manifest_auto.outputs.REGISTRY }}"   >> "$GITHUB_OUTPUT"
            echo "COMMIT_SHA=${{ steps.manifest_auto.outputs.COMMIT_SHA }}" >> "$GITHUB_OUTPUT"
          else
            echo "TAG=${{ steps.manifest_manual.outputs.TAG }}"           >> "$GITHUB_OUTPUT"
            echo "REGISTRY=${{ steps.manifest_manual.outputs.REGISTRY }}" >> "$GITHUB_OUTPUT"
            echo "COMMIT_SHA=${{ github.sha }}"                           >> "$GITHUB_OUTPUT"
          fi
          
          echo "üè∑Ô∏è  Final deployment configuration:"
          echo "   Image tag: ${{ steps.manifest.outputs.TAG }}"
          echo "   Registry: ${{ steps.manifest.outputs.REGISTRY }}"
          echo "   Commit: ${{ steps.manifest.outputs.COMMIT_SHA }}"

      # --- Pre-deployment Verification ---
      - name: Verify images exist in registry
        run: |
          echo "üîç Verifying images exist in ACR..."
          ACR_NAME="$(echo "${{ steps.manifest.outputs.REGISTRY }}" | cut -d'.' -f1)"
          TAG="${{ steps.manifest.outputs.TAG }}"
          
          # Check if all required images exist
          for service in product-service order-service frontend; do
            echo "Checking $service:$TAG..."
            if az acr repository show-tags --name "$ACR_NAME" --repository "$service" | grep -q "\"$TAG\""; then
              echo "‚úÖ $service:$TAG exists"
            else
              echo "‚ùå $service:$TAG not found!"
              echo "Available tags for $service:"
              az acr repository show-tags --name "$ACR_NAME" --repository "$service" --top 5
              exit 1
            fi
          done

      # --- Database Deployment (if needed) ---
      - name: Deploy databases (if not exists)
        env:
          NS: ${{ github.event.inputs.namespace || 'default' }}
        run: |
          echo "üóÑÔ∏è  Ensuring databases are deployed..."
          
          # Check if databases are already running
          if ! kubectl get deployment product-db-deployment-w08e1 -n "$NS" > /dev/null 2>&1; then
            echo "Deploying product database..."
            kubectl apply -n "$NS" -f k8s/product-db.yaml
          fi
          
          if ! kubectl get deployment order-db-deployment-w08e1 -n "$NS" > /dev/null 2>&1; then
            echo "Deploying order database..."
            kubectl apply -n "$NS" -f k8s/order-db.yaml
          fi
          
          echo "‚úÖ Database deployments ensured"

      # --- Application Deployment ---
      - name: Apply Kubernetes manifests
        env:
          NS: ${{ github.event.inputs.namespace || 'default' }}
        run: |
          echo "üì¶ Applying Kubernetes manifests..."
          
          # Apply configuration first
          kubectl apply -n "$NS" -f k8s/configmaps.yaml
          kubectl apply -n "$NS" -f k8s/secrets.yaml
          
          # Apply application manifests
          kubectl apply -n "$NS" -f k8s/product-service.yaml
          kubectl apply -n "$NS" -f k8s/order-service.yaml
          kubectl apply -n "$NS" -f k8s/frontend.yaml
          
          echo "‚úÖ Manifests applied successfully"

      # --- Image Updates ---
      - name: Update deployment images
        env:
          NS:  ${{ github.event.inputs.namespace || 'default' }}
          REG: ${{ steps.manifest.outputs.REGISTRY }}
          TAG: ${{ steps.manifest.outputs.TAG }}
        run: |
          echo "üîÑ Updating deployment images to $TAG..."
          
          # Update images with explicit container names (no auto-detection)
          kubectl -n "$NS" set image deploy/product-service-w08e1 product-service-container="$REG/product-service:$TAG"
          kubectl -n "$NS" set image deploy/order-service-w08e1 order-service-container="$REG/order-service:$TAG"
          kubectl -n "$NS" set image deploy/frontend frontend="$REG/frontend:$TAG"
          
          echo "‚úÖ Image updates applied"

      # --- Rollout Management ---
      - name: Wait for deployments to complete
        env:
          NS: ${{ github.event.inputs.namespace || 'default' }}
        run: |
          echo "‚è≥ Waiting for rollouts to complete..."
          
          for DEP in product-service-w08e1 order-service-w08e1 frontend; do
            echo "Waiting for $DEP rollout..."
            if ! kubectl -n "$NS" rollout status "deploy/$DEP" --timeout=600s; then
              echo "‚ùå Rollout failed for $DEP"
              echo "Deployment description:"
              kubectl -n "$NS" describe deploy "$DEP"
              echo "Pod status:"
              kubectl -n "$NS" get pods -l app=$(echo $DEP | sed 's/-w08e1$//') -o wide
              echo "Recent events:"
              kubectl -n "$NS" get events --sort-by=.metadata.creationTimestamp --field-selector involvedObject.name=$DEP
              exit 1
            else
              echo "‚úÖ $DEP rollout completed successfully"
            fi
          done

      # --- Service Discovery & Configuration ---
      - name: Wait for LoadBalancer IPs
        id: services
        env:
          NS: ${{ github.event.inputs.namespace || 'default' }}
        run: |
          echo "üåê Waiting for LoadBalancer external IPs..."
          
          # Wait for external IPs with better error handling
          for service in "product-service-w08e1:PRODUCT_IP" "order-service-w08e1:ORDER_IP" "frontend-w08e1:FRONT_IP"; do
            svc_name=$(echo $service | cut -d: -f1)
            var_name=$(echo $service | cut -d: -f2)
            
            echo "Waiting for $svc_name external IP..."
            for i in {1..60}; do
              IP=$(kubectl get svc "$svc_name" -n "$NS" -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
              if [ -n "$IP" ] && [ "$IP" != "null" ]; then
                echo "$var_name=$IP" >> "$GITHUB_OUTPUT"
                echo "‚úÖ $svc_name: $IP"
                break
              fi
              if [ $i -eq 60 ]; then
                echo "‚ùå Timeout waiting for $svc_name external IP"
                kubectl describe svc "$svc_name" -n "$NS"
                exit 1
              fi
              sleep 10
            done
          done

      - name: Configure frontend runtime
        env:
          NS: ${{ github.event.inputs.namespace || 'default' }}
        run: |
          echo "‚öôÔ∏è  Configuring frontend runtime..."
          
          # Create runtime configuration
          cat > config.js << EOF
          window.__CONFIG__ = {
            PRODUCT_API_URL: 'http://${{ steps.services.outputs.PRODUCT_IP }}:8000',
            ORDER_API_URL: 'http://${{ steps.services.outputs.ORDER_IP }}:8001',
            VERSION: '${{ steps.manifest.outputs.TAG }}',
            DEPLOYED_AT: '$(date -u +%Y-%m-%dT%H:%M:%SZ)'
          };
          EOF
          
          # Update ConfigMap and restart frontend
          kubectl -n "$NS" create configmap frontend-config --from-file=config.js --dry-run=client -o yaml | kubectl apply -f -
          kubectl -n "$NS" rollout restart deploy/frontend
          kubectl -n "$NS" rollout status deploy/frontend --timeout=300s
          
          echo "‚úÖ Frontend configuration updated"

      # --- Deployment Summary ---
      - name: Deployment summary
        run: |
          echo "üéâ Deployment completed successfully!"
          echo ""
          echo "üìã Deployment Summary:"
          echo "   Environment: ${{ github.event.inputs.environment || 'production' }}"
          echo "   Namespace: ${{ github.event.inputs.namespace || 'default' }}"
          echo "   Image Tag: ${{ steps.manifest.outputs.TAG }}"
          echo "   Commit: ${{ steps.manifest.outputs.COMMIT_SHA }}"
          echo ""
          echo "üåê Application Endpoints:"
          echo "   Frontend:  http://${{ steps.services.outputs.FRONT_IP }}"
          echo "   Products:  http://${{ steps.services.outputs.PRODUCT_IP }}:8000"
          echo "   Orders:    http://${{ steps.services.outputs.ORDER_IP }}:8001"
          echo ""
          echo "‚úÖ All services are ready!"